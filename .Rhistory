cats
cat}
MASS
MASS()
head(iris)
#| label: tbl-summarySpecies
#| tbl-cap: Summary statistics for each species
iris |>
summarize( 'Mean'= mean(Sepal.Length),
'Median'= median(Sepal.Length),
'St. Dev'= sd(Sepal.Length),
'Min'= min(Sepal.Length),
'Max'= max(Sepal.Length),
'IQR'= quantile(Sepal.Length, 0.75) - quantile(Sepal.Length, 0.25),
'Sample size'= n(),
.by = Species) |>
gt()
#| label: libraries
library(ggplot2)
library(tidyverse)
library(gt)
library(patchwork)
library(gridExtra)
library(moderndive)
#| label: tbl-summarySpecies
#| tbl-cap: Summary statistics for each species
iris |>
summarize( 'Mean'= mean(Sepal.Length),
'Median'= median(Sepal.Length),
'St. Dev'= sd(Sepal.Length),
'Min'= min(Sepal.Length),
'Max'= max(Sepal.Length),
'IQR'= quantile(Sepal.Length, 0.75) - quantile(Sepal.Length, 0.25),
'Sample size'= n(),
.by = Species) |>
gt()
#| label: tbl-summarysepallength
#| tbl-cap: Summary statistics for sepal length by species
iris |>
summarize( 'Mean'= mean(Sepal.Length),
'Median'= median(Sepal.Length),
'St. Dev'= sd(Sepal.Length),
'Min'= min(Sepal.Length),
'Max'= max(Sepal.Length),
'IQR'= quantile(Sepal.Length, 0.75) - quantile(Sepal.Length, 0.25),
'Sample size'= n(),
.by = Species) |>
gt()
#| label: tbl-summarysepalwidth
#| tbl-cap: Summary statistics for sepal width by species
iris |>
summarize( 'Mean'= mean(Sepal.Width),
'Median'= median(Sepal.Width),
'St. Dev'= sd(Sepal.Width),
'Min'= min(Sepal.Width),
'Max'= max(Sepal.Width),
'IQR'= quantile(Sepal.Width, 0.75) - quantile(Sepal.Width, 0.25),
'Sample size'= n(),
.by = Species) |>
gt()
#| label: tbl-summarysepallength
#| tbl-cap: Summary statistics for sepal length by species
iris |>
summarize( 'Mean'= mean(Sepal.Length),
'Median'= median(Sepal.Length),
'St. Dev'= sd(Sepal.Length),
'Min'= min(Sepal.Length),
'Max'= max(Sepal.Length),
'IQR'= quantile(Sepal.Length, 0.75) - quantile(Sepal.Length, 0.25),
'Sample size'= n(),
.by = Species) |>
gt() |>
fmt_number(decimals = 2)
#| label: tbl-summarysepalwidth
#| tbl-cap: Summary statistics for sepal width by species
iris |>
summarize( 'Mean'= mean(Sepal.Width),
'Median'= median(Sepal.Width),
'St. Dev'= sd(Sepal.Width),
'Min'= min(Sepal.Width),
'Max'= max(Sepal.Width),
'IQR'= quantile(Sepal.Width, 0.75) - quantile(Sepal.Width, 0.25),
'Sample size'= n(),
.by = Species) |>
gt() |>
fmt_number(decimals = 2)
#| label: tbl-summarysepalwidth
#| tbl-cap: Summary statistics for sepal width by species
iris |>
summarize( 'Mean'= mean(Sepal.Width),
'Median'= median(Sepal.Width),
'St. Dev'= sd(Sepal.Width),
'Min'= min(Sepal.Width),
'Max'= max(Sepal.Width),
'IQR'= quantile(Sepal.Width, 0.75) - quantile(Sepal.Width, 0.25),
'Sample size'= n(),
.by = Species) |>
summarize( 'Mean'= mean(Sepal.Width),
'Median'= median(Sepal.Width),
'St. Dev'= sd(Sepal.Width),
'Min'= min(Sepal.Width),
'Max'= max(Sepal.Width),
'IQR'= quantile(Sepal.Width, 0.75) - quantile(Sepal.Width, 0.25),
'Sample size'= n(),
.by = Species) |>
gt() |>
fmt_number(decimals = 2)
#| label: fig-boxplot
#| lbl-cap: Speal l dmkdsmc
ggplot(iris, aes(x = Species, y = Sepal.Length)) +
geom_boxplot()
#| label: fig-boxplot
#| lbl-cap: Speal l dmkdsmc
ggplot(iris, aes(x = Species, y = Sepal.Length)) +
geom_boxplot() +
labels(x = "tqm")
#| label: fig-boxplot
#| lbl-cap: Speal l dmkdsmc
ggplot(iris, aes(x = Species, y = Sepal.Length)) +
geom_boxplot() +
labs(x = "tqm")
#| label: LM
#|
model = lm(Sepal.Length ~ Sepal.Width, data = iris)
#| label: LM
#|
model = lm(Sepal.Length ~ Sepal.Width, data = iris)
model
y = seq(-7,10,by=0.01)
plot(y, 0.5*(dnorm(y,1,2) + dnorm(y,2,2)), type="l", ylab = "Density"
plot(y, 0.5*(dnorm(y,1,2) + dnorm(y,2,2)), type="l", ylab = "Density") +
plot(y, 0.5*(dnorm(y,1,2) + dnorm(y,2,2)), type="l", ylab = "Density") +
title(main="0.5N(y|1,2)+0.5N(y|2,2)")
y = seq(-7,10,by=0.01)
plot(y, 0.5*(dnorm(y,1,2) + dnorm(y,2,2)), type="l", ylab = "Density") +
title(main="0.5N(y|1,2)+0.5N(y|2,2)")
theta<-rexp(n=100000,rate=1)
psi<-sqrt(theta)*log(theta) /(1+theta)
hist(psi,100)
theta<-rexp(n=100000,rate=1)
psi<-sqrt(theta)*log(theta) /(1+theta)
hist(psi,100)
mean(psi)
var(psi)
mean(psi>0)
quantile(psi,probs=c(0.025,0.975))
sort(psi)[100000*c(0.025,0.975)+c(0,1)]
# Version of nimbleMCMC that doesn't compile code in C++, for maximum capability.
nimbleMCMC2 <- function (code, constants = list(), data = list(), inits, dimensions = list(),
model, monitors, thin = 1, niter = 10000, nburnin = 0, nchains = 1,
check = TRUE, setSeed = FALSE, progressBar = getNimbleOption("MCMCprogressBar"),
samples = TRUE, samplesAsCodaMCMC = FALSE, summary = FALSE,
WAIC = FALSE)
{
if (missing(code) && missing(model))
stop("must provide either code or model argument")
if (!samples && !summary && !WAIC)
stop("no output specified, use samples = TRUE, summary = TRUE, or WAIC = TRUE")
if (!missing(code) && inherits(code, "modelBaseClass"))
model <- code
Rmodel <- mcmc_createModelObject(model, inits, nchains, setSeed,
code, constants, data, dimensions, check)
conf <- configureMCMC(Rmodel, monitors = monitors, thin = thin,
enableWAIC = WAIC, print = FALSE)
Rmcmc <- buildMCMC(conf)
runMCMC(Rmcmc, niter = niter, nburnin = nburnin, nchains = nchains,
inits = inits, setSeed = setSeed, progressBar = progressBar,
samples = samples, samplesAsCodaMCMC = samplesAsCodaMCMC,
summary = summary, WAIC = WAIC)
}
knitr::opts_chunk$set(message=FALSE,warning=FALSE)
library(kableExtra)
knitr::opts_chunk$set(message=FALSE,warning=FALSE)
library(kableExtra)
library(nimble) # Load in the NIMBLE package.
iq_constants <- list(n=43)
iq_data <- list(y = 10)
iq_inits <- list(theta = 0.5)
iq_init_fun <- function(){
inits <- list(theta = runif(1,0,1)) # Note theta is a probability, so we should simulate initial values between 0 and 1.
return(inits)
}
# Example output:
iq_init_fun()
iq_prior_code <- nimbleCode({
theta ~ dunif(0,1) # Uniform(0,1) prior distribution for theta.
})
source('nimbleMCMC2.R') # Modified version of nimbleMCMC() that does not compile the MCMC.
iq_prior_samples <- nimbleMCMC2(
code = iq_prior_code, # The model code.
constants = iq_constants, # Constants.
data = iq_data, # Data.
inits = iq_init_fun(), # Our initial values function.
monitors = c('theta'), # Variables we want to save MCMC samples of.
niter = 2000 # Number of MCMC iterations.
)
# Display the first 10 samples:
iq_prior_samples[1:10,]
library(tidyverse) # Load in the tidyverse family of packages (ggplot, dplyr2 etc.).
iq_prior_samples_df <- iq_prior_samples %>% as.data.frame() %>%
mutate(iteration = 1:nrow(iq_prior_samples)) # Convert the samples matrix into a data frame and add a variable for the MCMC iteration number.
# Trace plot of samples from theta's prior distribution.
ggplot(iq_prior_samples_df,aes(x = iteration,y = theta)) + geom_line() +
labs(x = 'MCMC iteration')
# Histogram of samples from theta's prior distribution.
ggplot(iq_prior_samples_df,aes(x = theta,y=after_stat(density))) + geom_histogram(breaks=seq(0,1,by=0.2))
iq_code <- nimbleCode({
y ~ dbin(theta,n) # Binomial likelihood for y.
theta ~ dunif(0,1) # Uniform(0,1) prior distribution for theta.
})
iq_posterior_samples <- nimbleMCMC2(
code = iq_code,
constants = iq_constants,
data = iq_data,
inits = list(theta=0.9), # Note we're using a fixed initial value for illustration purposes.
monitors = c('theta'),
niter = 2000,
setSeed = 4598230,
nburnin = 400
)
iq_posterior_samples_df <- iq_posterior_samples %>% as.data.frame() %>%
mutate(iteration = 1:nrow(iq_posterior_samples))
# Trace plot of samples from theta's posterior distribution.
ggplot(iq_posterior_samples_df,aes(x = iteration,y = theta)) + geom_line() +
labs(x = 'MCMC iteration')
iq_posterior_samples <- nimbleMCMC2(
code = iq_code,
constants = iq_constants,
data = iq_data,
inits = list(theta=0.9), # Note we're using a fixed initial value for illustration purposes.
monitors = c('theta'),
niter = 2000,
setSeed = 4598230,
nburnin = 0
)
iq_posterior_samples_df <- iq_posterior_samples %>% as.data.frame() %>%
mutate(iteration = 1:nrow(iq_posterior_samples))
# Trace plot of samples from theta's posterior distribution.
ggplot(iq_posterior_samples_df,aes(x = iteration,y = theta)) + geom_line() +
labs(x = 'MCMC iteration')
iq_posterior_samples <- nimbleMCMC2(
code = iq_code,
constants = iq_constants,
data = iq_data,
inits = list(theta=0.9), # Note we're using a fixed initial value for illustration purposes.
monitors = c('theta'),
niter = 2000,
setSeed = 4598230,
nburnin = 800
)
iq_posterior_samples_df <- iq_posterior_samples %>% as.data.frame() %>%
mutate(iteration = 1:nrow(iq_posterior_samples))
# Trace plot of samples from theta's posterior distribution.
ggplot(iq_posterior_samples_df,aes(x = iteration,y = theta)) + geom_line() +
labs(x = 'MCMC iteration')
iq_posterior_samples <- nimbleMCMC2(
code = iq_code,
constants = iq_constants,
data = iq_data,
inits = iq_init_fun,
monitors = c('theta'),
niter = 2000,
setSeed = 4598230,
nburnin = 1000
)
iq_posterior_samples_df <- iq_posterior_samples %>% as.data.frame() %>%
mutate(iteration = 1:nrow(iq_posterior_samples))
# Trace plot of samples from theta's posterior distribution.
ggplot(iq_posterior_samples_df,aes(x = iteration,y = theta)) + geom_line() +
labs(x = 'MCMC iteration')
knitr::opts_chunk$set(message=FALSE,warning=FALSE)
library(kableExtra)
theta_table <- tibble(Prior='Uniform(0,1)',Expectation=mean(iq_posterior_samples[,'theta']),`Lower 95% interval`=quantile(iq_posterior_samples[,'theta'],0.025),
Median=median(iq_posterior_samples[,'theta']),`Upper 95% interval`=quantile(iq_posterior_samples[,'theta'],0.975),
`Probability`=mean(iq_posterior_samples[,'theta']<=0.5))
theta_table%>%kable(digits=3)%>%kable_styling()
## Beta(0.5,0.5)
iq_code_2 <- nimbleCode({
y ~ dbin(theta,n) # Binomial likelihood for y.
theta ~ dbeta(0.5,0.5) # Beta(0.5,0.5) prior for theta.
})
iq_posterior_samples_2 <- nimbleMCMC2(
code = iq_code_2,
constants = iq_constants,
data = iq_data,
inits = iq_init_fun, # Note we're using a fixed initial value for illustration purposes.
monitors = c('theta'),
niter = 2000,
setSeed = 4598230,
nburnin = 1000
)
## Beta(12,12)
iq_code_3 <- nimbleCode({
y ~ dbin(theta,n) # Binomial likelihood for y.
theta ~ dbeta(12,12) # Beta(12,12) prior for theta.
})
iq_posterior_samples_3 <- nimbleMCMC2(
code = iq_code_3,
constants = iq_constants,
data = iq_data,
inits = iq_init_fun, # Note we're using a fixed initial value for illustration purposes.
monitors = c('theta'),
niter = 2000,
setSeed = 4598230,
nburnin = 1000
)
## Normal(0,4) for logit(theta)
iq_code_4 <- nimbleCode({
y ~ dbin(theta,n) # Binomial likelihood for y.
logit(theta) ~ dnorm(0,sd=4) # Normal(0,sigma=4) prior for logit(theta).
})
iq_posterior_samples_4 <- nimbleMCMC2(
code = iq_code_4,
constants = iq_constants,
data = iq_data,
inits = list(logit_theta=logit(0.9)), # Note we're using a fixed initial value for illustration purposes.
monitors = c('theta'),
niter = 2000,
setSeed = 4598230,
nburnin = 1000
)
n_samples <-1000
theta_samples_df <- tibble(Prior=c(rep('Uniform(0,1)',n_samples),rep('Beta(0.5,0.5)',n_samples),
rep('Beta(12,12)',n_samples),rep('logit-Normal(0,4)',n_samples)),
samples=c(iq_posterior_samples[1:1000,'theta'],iq_posterior_samples_2[,'theta'],
iq_posterior_samples_3[,'theta'],iq_posterior_samples_4[,'theta']))
complete_theta_table <- theta_samples_df%>%group_by(Prior)%>%summarise(Expectation=mean(samples),`Lower 95% Interval`=quantile(samples,0.025),
Median=median(samples),`Upper 95% Interval`=quantile(samples,0.975),
Probability=mean(samples<=0.5))
complete_theta_table%>%kable(digits=3)%>%kable_styling()
prior_samples_df <- tibble(Prior=c(rep('Uniform(0,1)',n_samples),rep('Beta(0.5,0.5)',n_samples),
rep('Beta(12,12)',n_samples),rep('logit-Normal(0,4)',n_samples)),
samples=c(runif(n_samples,0,1),rbeta(n_samples,0.5,0.5),rbeta(n_samples,12,12),
expit(rnorm(n_samples,0,4))))
# Density plots of prior and posterior MCMC samples.
ggplot()+
geom_density(data=prior_samples_df,aes(x=samples,colour=Prior,linetype='Prior density'),adjust=2,trim=TRUE)+
geom_density(data=theta_samples_df,aes(x=samples,colour=Prior,linetype='Posterior density'),adjust=2,trim=TRUE)+
facet_wrap(~Prior)+
labs(x=expression(theta),y=NULL)+
scale_color_brewer(palette='Set1',guide="none")+scale_linetype(name=NULL)
n_code <- nimbleCode({
y ~ dbin(theta,n) # Binomial likelihood for y.
n ~ T(dpois(43),10,) # Poisson(43) prior, truncated below at 10.
})
n_posterior_samples <- nimbleMCMC2(
code = n_code,
constants = list(theta=0.5), # We need to tell the model that theta=0.5.
data = iq_data,
inits = list(n=20), # n is unknown, so we need to provide an initial value.
monitors = c('n'),
niter = 2000,
setSeed = 4598230,
nburnin = 1000
)
ggplot(data.frame(n=n_posterior_samples[,'n']))+geom_histogram(aes(x=n))+
labs(x='Sample size (n)',y='Count')
mean(n_posterior_samples[,'n']<=43)
install.packages('tinytex')
tinytex::install_tinytex()
y
tinytex::install_tinytex()
Y
tinytex::install_tinytex()
setwd("C:/Users/carlo/Desktop/R/SEM2/Data Mining ML/Datasets for week 2-20240324")
euormat = eurodist
euormat = eurodist
euro.cmds = cmdscale(euromat, k=2)
euromat = eurodist
euro.cmds = cmdscale(euromat, k=2)
euromat = eurodist
euro.cmds = cmdscale(euromat, k=2)
eurodist
euro.cmds
text(euro.cmds[,1],euro.cmds[,2], cex=.7)
plot(euro.cmds[,1],euro.cmds[,2], type="n", asp=1)
text(euro.cmds[,1],euro.cmds[,2], cex=.7)
plot(euro.cmds[,1],euro.cmds[,2], type="n", asp=1)
text(euro.cmds[,1],euro.cmds[,2], labels=labels(euromat) cex=.7)
plot(euro.cmds[,1],euro.cmds[,2], type="n", asp=1)
text(euro.cmds[,1],euro.cmds[,2], labels=labels(euromat), cex=.7)
library(smacof)
crimes
crime.dist = sim2diss(crimes, method = "corr")
set,seed(1)
set.seed(1)
crime.mds = mds(crime.dist, ndim = 2, type = "interval")
plot(crime.mds)
crime.mds1 = mds(crime.dist, ndim=1, type= "interval")
plot(crime.mds1)
plot(crime.mds1$conf, rep(0,7))
text(crime.mds1$conf, 0.5 + rep(0,7), labels = names(crimes), cex = .7)
plot(crime.mds, plot.type = "Shepard")
plot(creme.mds1, plot.type = "Shepard")
plot(crime.mds, plot.type = "Shepard")
plot(crime.mds1, plot.type = "Shepard")
library(MASS)
crime.sammon = sammon(crime.dist, k = 2)
plot(crime.sammon)
crime.sammon
plot(crime.sammon[,1], crime.sammon[,2])
plot(crime.sammon$points[,1], crime.sammon$points[,2])
text(plot(crime.sammon$points[,1], crime.sammon$points[,2]), labels = names(crimes), cex = .7)
plot(crime.sammon$points[,1], crime.sammon$points[,2])
text(plot(crime.sammon$points[,1], crime.sammon$points[,2]), labels = names(crimes), cex = .7)
plot(crime.sammon$points[,1], crime.sammon$points[,2])
text(crime.sammon$points[,1], crime.sammon$points[,2], labels = names(crimes), cex = .7)
wish
diss = sim2diss(wish, method = 7)
set.seed(1)
res = mds(diss, type = "ordinal")
plot(res, asp = 1)
X = sort(runif(n))
n = 100
x = sort(runif(n))
y = 5*x**2 + x +0.1*rnorm(n)
plot(x,y)
reg.model = lm(y~x + I(x**2))
lines(x, fitted(reg.model), col = "red")
z = x + 1000
plot(x,y)
reg.model = lm(y~z + I(z**2))
lines(x, fitted(reg.model), col="red")
prostate = read.csv("prostate.csv")
paits(prostate)
pairs(prostate)
mod = lm(lpsa~. , data=prostate)
mod
prostate.pca = princomp(prostate[,-9])
mod.pcr = lm(prostate[,9]~ prostate.pca$scores)
coef(mod.pcr)
t(prostate.pca$loadings %*% mod.pcr$coefficients[-1])
let = read.csv("letter.csv")
let
library(smacof)
letter <- read.csv("letter.csv", row.names=1)
letter.dist <- sim2diss(letter, method=max(letter)) #z-s_ij
letter.dist <- as.dist(letter.dist)
letter.dist
#nonmetric MDS
#2D
set.seed(1)
letter.nmds2 <- mds(letter.dist, ndim=2, type="ordinal")
plot(letter.nmds2,asp=1)
plot(letter.nmds2, type = "Shepard")
plot(letter.nmds2, plot.type = "Shepard")
#3D
set.seed(1)
letter.nmds3 <- mds(letter.dist, ndim=3, type="ordinal")
library(rgl)
# plot3d(letter.nmds3$conf[,1],letter.nmds3$conf[,2],
#        letter.nmds3$conf[,3],type="",
#        xlab="Axis 1",ylab="Axis 2",zlab="Axis 3",asp=1)
text3d(letter.nmds3$conf[,1],letter.nmds3$conf[,2],
letter.nmds3$conf[,3],texts=names(letter.dist),asp=1)
plot(letter.nmds3,plot.type="Shepard")
N_dim <- 1:(nrow(letter)-1)
letter.nmds <- matrix(nrow=length(N_dim),ncol=2)
for (i in N_dim){
letter.nmds[i,1] <- i
letter.nmds[i,2] <- mds(letter.dist, ndim=i, type="ordinal")$stress
}
plot(letter.nmds, type="b", main="scree plot",
xlab="number of dimensions", ylab="stress-1")
Z <- seq(max(letter), by=1, length.out=100)
letter.z <- matrix(nrow=length(Z), ncol=2)
for (i in 1:length(Z)){
letter.dist <- sim2diss(letter, method=Z[i])
set.seed(1)
letter.z[i,1] <- Z[i]
letter.z[i,2] <- mds(letter.dist, ndim=3, type="ordinal")$stress
}
plot(letter.z, xlab="integer z", ylab="stress-1")
Seed <- 1:100
letter.seed <- matrix(nrow=length(Seed), ncol=1)
for (i in Seed){
letter.dist <- sim2diss(letter, method=max(letter))
set.seed(i)
letter.seed[i] <- mds(letter.dist,ndim=3, type="ordinal", init="random")$stress
}
hist(letter.seed, xlab="stress value", main="Histogram of stress values computed over 100 random initialisations")
employ <- read.table("eurojob.txt", header=TRUE, row.names=1)
setwd("C:/Users/carlo/Desktop/R/SEM2/Data Mining ML/Datasets for week 1-20240323")
employ <- read.table("eurojob.txt", header=TRUE, row.names=1)
employ
employ.sd <- scale(employ)
employ.dist <- dist(employ.sd) #to visualise countries as data points
employ.dist.var <- dist(t(employ.sd)) #to visualise variables as data points
emplot.dist
employ.dist
employ.dist.var
library(smacof)
set.seed(1)
employ.mds2 <- mds(employ.dist, ndim=2, type="interval")
plot(employ.mds2)
plot(employ.mds2,plot.type="Shepard")
employ.mds <- matrix(nrow=nrow(employ)-1,ncol=2)
for (i in 1:(nrow(employ)-1)){
employ.mds[i,1] <- i
set.seed(1)
employ.mds[i,2] <- mds(employ.dist, ndim=i, type="interval")$stress
}
plot(employ.mds, type="b", main="scree plot",
xlab="number of dimensions", ylab="stress")
#Sammon
library(MASS)
employ.sm <- sammon(employ.dist, k=2)
plot(employ.sm$points, type="n", xlab="Axis 1", ylab="Axis 2",asp=1)
text(employ.sm$points, labels=names(employ.dist))
employ.sh<-Shepard(employ.dist, employ.sm$points, p=2)
plot(employ.sh, pch=".")
lines(employ.sh$x, employ.sh$yf, type = "S")
